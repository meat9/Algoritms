# Теперь Гоша взялся за сортировку вставками.
# Алгоритм следующий: На i-том шаге мы делаем так, чтобы первые i элементов 
# массива шли в возрастающем порядке.
# 1) На первом шаге ничего делать не нужно - один элемент и так "отсортирован".
# 2) На втором шаге нужно сделать так, чтобы два первых элемента были верно отсортированы. 
# То есть если второй элемент оказался меньше первого, их нужно поменять местами.
# 3) На i - том шаге мы знаем, что первые i-1 элементов уже отсортированы. 
# Ищем, куда нужно вставить i-ый элемент.
# Для этого, начиная с позиции j = i - 1, сравниваем текущий элемент с элементом на позиции j. 
# Пока j - й элемент больше i-ого и j > 0, меняем элементы местами, и уменьшаем счетчик j на 1.
# Помогите Гоше написать код.
# Формат ввода
# В первой строке на вход подается число n - длина массива. n не превосходит 1000. 
# Во второй строке через пробел записаны n чисел. Каждое из чисел по модулю не превосходит 1000.
# Формат вывода
# Нужно вывести через пробел числа в отсортированном по возрастанию порядке.
# Пример 1
# Ввод	
# 14
# 5 3 7 2 8 26 -12 -30 -10 27 13 -20 -30 18
# Вывод
# -30 -30 -20 -12 -10 2 3 5 7 8 13 18 26 27


with open('input.txt') as f:
    n = int(f.readline())
    a = list(map(int, (f.readline().split())))
def insertion_sort(a):  
    # Сортировку начинаем со второго элемента, т.к. считается, что первый элемент уже отсортирован
    for i in range(1, len(a)):
        item_to_insert = a[i]
        # Сохраняем ссылку на индекс предыдущего элемента
        j = i - 1
        # Элементы отсортированного сегмента перемещаем вперёд, если они больше
        # элемента для вставки
        while j >= 0 and a[j] > item_to_insert:
            a[j + 1] = a[j]
            j -= 1
        # Вставляем элемент
        a[j + 1] = item_to_insert

# Проверяем, что оно работает
 
insertion_sort(a)  
print(*(a))